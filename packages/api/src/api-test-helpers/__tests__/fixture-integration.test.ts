import { describe, it, expect } from 'vitest'
import { TestEntityFixture } from '../fixtures/test-entity.fixture'

describe('Fixture Integration Examples', () => {
  const fixture = new TestEntityFixture()

  describe('Request fixtures usage', () => {
    it('should provide typed create requests for different scenarios', () => {
      // Test with valid create request
      const createRequest = fixture.requests.create.valid
      expect(createRequest).toEqual({
        name: 'New Test Entity',
        description: 'Created via API',
        isActive: true,
      })
      
      // Test with minimal request (only required fields)
      const minimalRequest = fixture.requests.create.minimal
      expect(minimalRequest).toEqual({
        name: 'Minimal Entity',
      })
      
      // TypeScript ensures only valid fields are used
      expect(createRequest.name).toBe('New Test Entity')
      expect(minimalRequest.name).toBe('Minimal Entity')
    })

    it('should provide typed update requests', () => {
      const updateRequest = fixture.requests.update.nameOnly
      expect(updateRequest).toEqual({
        name: 'Updated Name',
      })
      
      const fullUpdateRequest = fixture.requests.update.fullUpdate
      expect(fullUpdateRequest).toEqual({
        name: 'Fully Updated Entity',
        description: 'Updated description',
        isActive: false,
      })
    })

    it('should provide invalid requests for validation testing', () => {
      const invalidRequest = fixture.requests.invalid.emptyName
      expect(invalidRequest).toEqual({
        name: '',
        description: 'Invalid: empty name',
      })
    })
  })

  describe('Response fixtures with matchers', () => {
    it('should handle created responses with generated fields', () => {
      // Simulate API response for created entity
      const apiResponse = {
        id: '550e8400-e29b-41d4-a716-446655440000', // Generated
        name: 'New Test Entity',
        description: 'Created via API',
        isActive: true,
        createdAt: '2024-06-09T15:30:45.123Z', // Generated
        updatedAt: '2024-06-09T15:30:45.123Z', // Generated
      }

      // Using the fixture response with expect.any() matchers
      expect(apiResponse).toEqual(fixture.responses.created.fromValidRequest)
    })

    it('should handle updated responses with known IDs but generated timestamps', () => {
      // Simulate API response for updated entity
      const apiResponse = {
        id: '123e4567-e89b-12d3-a456-426614174002', // Known ID
        name: 'Updated Name',
        description: 'Second test entity for integration testing',
        isActive: false,
        createdAt: '2024-01-02T00:00:00.000Z', // Original timestamp
        updatedAt: '2024-06-09T15:35:20.456Z', // New generated timestamp
      }

      // Using the fixture response with expect.any() for updatedAt
      expect(apiResponse).toEqual(fixture.responses.updated.nameOnlyUpdate)
    })

    it('should provide known entity responses for exact matching', () => {
      // For existing entities with known timestamps, use exact matching
      const knownEntityResponse = fixture.responses.entities.testEntity1
      
      expect(knownEntityResponse).toEqual({
        id: '123e4567-e89b-12d3-a456-426614174001',
        name: 'Test Entity One',
        description: 'First test entity for integration testing',
        isActive: true,
        createdAt: '2024-01-01T00:00:00.000Z',
        updatedAt: '2024-01-01T00:00:00.000Z',
      })
    })
  })

  describe('Error fixtures usage', () => {
    it('should provide error response fixtures', () => {
      expect(fixture.responses.errors.notFound).toEqual({
        statusCode: 404,
        message: 'Entity not found',
      })

      expect(fixture.responses.errors.validationError).toEqual({
        statusCode: 400,
      })
    })
  })

  describe('Example test scenarios', () => {
    it('demonstrates how to test POST /api/test-entities', async () => {
      // Use request fixture
      const requestPayload = fixture.requests.create.valid
      
      // Simulate POST request (this would be actual fastify.inject in real test)
      const mockApiResponse = {
        id: '123e4567-e89b-12d3-a456-426614174999', // Generated by database
        name: requestPayload.name,
        description: requestPayload.description,
        isActive: requestPayload.isActive,
        createdAt: '2024-06-09T15:30:45.123Z', // Generated by database
        updatedAt: '2024-06-09T15:30:45.123Z', // Generated by database
      }
      
      // Use response fixture with matchers for assertion
      expect(mockApiResponse).toEqual(fixture.responses.created.fromValidRequest)
    })

    it('demonstrates how to test PUT /api/test-entities/:id', async () => {
      // Use update request fixture
      const requestPayload = fixture.requests.update.nameOnly
      const entityId = '123e4567-e89b-12d3-a456-426614174002'
      
      // Simulate PUT request response
      const mockApiResponse = {
        id: entityId,
        name: requestPayload.name!, // Updated field
        description: 'Second test entity for integration testing', // Unchanged
        isActive: false, // Unchanged
        createdAt: '2024-01-02T00:00:00.000Z', // Original timestamp
        updatedAt: '2024-06-09T15:35:20.456Z', // New timestamp
      }
      
      // Use response fixture with matcher for updatedAt
      expect(mockApiResponse).toEqual(fixture.responses.updated.nameOnlyUpdate)
    })

    it('demonstrates how to test validation errors', async () => {
      // Use invalid request fixture
      const requestPayload = fixture.requests.invalid.emptyName
      
      // Simulate validation error response
      const mockErrorResponse = {
        statusCode: 400,
        // Additional error details would be here in real API
      }
      
      // Use error fixture for assertion
      expect(mockErrorResponse.statusCode).toBe(fixture.responses.errors.validationError.statusCode)
    })
  })
})